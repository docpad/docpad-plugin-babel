// Generated by CoffeeScript 1.9.1
(function() {
  var badgeUtil,
    hasProp = {}.hasOwnProperty;

  module.exports = badgeUtil = {
    miscBadges: {
      travis: function(opts) {
        var image, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.travis || !opts.username || !opts.name) {
          return '';
        } else {
          image = "https://img.shields.io/travis/" + opts.username + "/" + opts.name + "/master.svg";
          url = "http://travis-ci.org/" + opts.username + "/" + opts.name;
        }
        return "[![Build Status](" + image + ")](" + url + " \"Check this project's build status on TravisCI\")";
      },
      npm: function(opts) {
        var image, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.npm || !opts.name) {
          return '';
        } else {
          image = "https://img.shields.io/npm/v/" + opts.name + ".svg";
          url = "https://npmjs.org/package/" + opts.name;
        }
        return "[![NPM version](" + image + ")](" + url + " \"View this project on NPM\")";
      },
      npmdownloads: function(opts) {
        var image, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.npmdownloads || !opts.name) {
          return '';
        } else {
          image = "https://img.shields.io/npm/dm/" + opts.name + ".svg";
          url = "https://npmjs.org/package/" + opts.name;
        }
        return "[![NPM downloads](" + image + ")](" + url + " \"View this project on NPM\")";
      },
      waffleio: function(opts) {
        var image, label, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.waffleio || !opts.repo) {
          return '';
        } else {
          label = opts.badges.waffleio;
          if (label === true) {
            label = 'ready';
          }
          image = "https://badge.waffle.io/" + opts.repo + ".png?label=" + label;
          url = "http://waffle.io/" + opts.repo;
        }
        return "[![Stories in Ready](" + image + ")](" + url + ")";
      },
      david: function(opts) {
        var image, repo, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.david) {
          return '';
        } else if (opts.badges.daviddev !== true) {
          repo = opts.badges.david;
        } else if (opts.repo) {
          repo = opts.repo;
        } else {
          return '';
        }
        image = "https://img.shields.io/david/" + repo + ".svg";
        url = "https://david-dm.org/" + repo;
        return "[![Dependency Status](" + image + ")](" + url + ")";
      },
      daviddev: function(opts) {
        var image, repo, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.daviddev) {
          return '';
        } else if (opts.badges.daviddev !== true) {
          repo = opts.badges.daviddev;
        } else if (opts.repo) {
          repo = opts.repo;
        } else {
          return '';
        }
        image = "https://img.shields.io/david/dev/" + repo + ".svg";
        url = "https://david-dm.org/" + repo + "#info=devDependencies";
        return "[![Dev Dependency Status](" + image + ")](" + url + ")";
      }
    },
    donationBadges: {
      gratipay: function(opts) {
        var image, name, url;
        if (opts == null) {
          opts = {};
        }
        name = opts.badges.gratipay || opts.badges.gittip;
        if (!name) {
          return '';
        } else {
          image = "https://img.shields.io/gratipay/" + name + ".svg";
          url = "https://www.gratipay.com/" + name + "/";
        }
        return "[![Gratipay donate button](" + image + ")](" + url + " \"Donate weekly to this project using Gratipay\")";
      },
      flattr: function(opts) {
        var image, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.flattr) {
          return '';
        } else {
          image = "https://img.shields.io/badge/flattr-donate-yellow.svg";
          url = "http://flattr.com/thing/" + opts.badges.flattr;
        }
        return "[![Flattr donate button](" + image + ")](" + url + " \"Donate monthly to this project using Flattr\")";
      },
      paypal: function(opts) {
        var image, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.paypal) {
          return '';
        } else {
          image = "https://img.shields.io/badge/paypal-donate-yellow.svg";
          url = "https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=" + opts.badges.paypal;
        }
        return "[![PayPayl donate button](" + image + ")](" + url + " \"Donate once-off to this project using Paypal\")";
      },
      bitcoin: function(opts) {
        var image, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.bitcoin) {
          return '';
        } else {
          image = "https://img.shields.io/badge/bitcoin-donate-yellow.svg";
          url = opts.badges.bitcoin;
        }
        return "[![BitCoin donate button](" + image + ")](" + url + " \"Donate once-off to this project using BitCoin\")";
      },
      wishlist: function(opts) {
        var image, url;
        if (opts == null) {
          opts = {};
        }
        if (!opts.badges.wishlist) {
          return '';
        } else {
          image = "https://img.shields.io/badge/wishlist-donate-yellow.svg";
          url = opts.badges.wishlist;
        }
        return "[![Wishlist browse button](" + image + ")](" + url + " \"Buy an item on our wishlist for us\")";
      }
    },
    getBadgesSection: function(opts) {
      if (opts == null) {
        opts = {};
      }
      return badgeUtil.getTypedBadges('misc', opts) + '<br/>\n' + badgeUtil.getTypedBadges('donation', opts);
    },
    getTypedBadges: function(type, opts) {
      var fn, name, ref, result, results;
      if (opts == null) {
        opts = {};
      }
      results = [];
      ref = badgeUtil[type + 'Badges'];
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        fn = ref[name];
        result = fn.call(this, opts);
        if (result) {
          results.push(result);
        }
      }
      return results.join('\n');
    }
  };

}).call(this);
